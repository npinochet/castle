//go:build ignore

//kage:unit pixels
package main

var Scale float

func getColor(pos vec2) vec4 {
	// Get a starting color using better-than-bilinear filtering
	col := imageSrc0UnsafeAt(pos)

	// Offset the UVs for the red and blue channels to simulate deconvergence
	halfPixel := Scale / 2.0
	col.r = imageSrc0UnsafeAt(pos + halfPixel).r
	col.b = imageSrc0UnsafeAt(pos - halfPixel).b

	// Calculate a grayscale color, keeping luminosity relatively constant
	grayf := (0.2989 * col.r) + (0.5870 * col.g) + (0.1140 * col.b)
	gray := vec4(grayf, grayf, grayf, 1.0)

	return mix(col, gray, 0.4)
}

func applyMask(color vec4, pos vec2) vec4 {
	/// Gets a color from the phosphor mask and brightens the shadowed pragma regions if desired
	/// Multiplies the resulting color into the output

	// Get color from the mask texture
	subPixels := 4.0
	adjust := max(floor(Scale/subPixels), 1)
	pos /= adjust
	maskColor := imageSrc1UnsafeAt(pos)

	// Brighten the black parts of the mask to improve overall brightness
	uMaskBrightness := 0.8
	maskColor.rgb += color.rgb * uMaskBrightness

	// Apply the result
	return color * maskColor
}

func applyScanlines(color vec4, pos vec2) vec4 {
	/// Gets the brightness of the current fragment with respect to scanlines
	/// Multiplies the resulting brightness into the output
	uv := pos / imageDstSize()

	// Linear sawtooth wave applied either horizontally or vertically
	uScanIntensity := 0.2
	uZoom := 1.3
	resolution := imageDstSize() / Scale
	scanLum := (mod(uv.y*uZoom, 1/resolution.y) * resolution.y)

	// Turn the sawtooth into a triangle wave, smoothen it, and scale by the intensity uniform
	scanLum = (smoothstep(0.0, 0.5, abs(scanLum-0.5)) * (-2.0 * uScanIntensity)) + 1.0

	// Apply the result
	return vec4(color.rgb*scanLum, color.a)
}

func applyGlow(color vec4, pos vec2) vec4 {
	/// Applies a short-range bloom effect to bleed bright pixels into the surrounding area
	/// Should typically be applied after scanlines and the phosphor mask

	uGlowAmount := 0.3

	texelSize := Scale
	// Accumulate samples from the surrounding texels
	glowColor := imageSrc0UnsafeAt(pos)
	// Diagonals
	glowColor += imageSrc0UnsafeAt(pos + vec2(-texelSize, -texelSize))
	glowColor += imageSrc0UnsafeAt(pos + vec2(-texelSize, texelSize))
	glowColor += imageSrc0UnsafeAt(pos + vec2(texelSize, -texelSize))
	glowColor += imageSrc0UnsafeAt(pos + vec2(texelSize, texelSize))
	// Cardinals
	glowColor += imageSrc0UnsafeAt(pos + vec2(0, -texelSize))
	glowColor += imageSrc0UnsafeAt(pos + vec2(0, texelSize))
	glowColor += imageSrc0UnsafeAt(pos + vec2(-texelSize, 0))
	glowColor += imageSrc0UnsafeAt(pos + vec2(texelSize, 0))
	// Reduce the values back down to 0-1
	glowColor *= 0.11111111

	// Add the result to the output
	return vec4(color.rgb+(glowColor.rgb*uGlowAmount), color.a)
}

func Fragment(dstPos vec4, srcPos vec2) vec4 {
	color := getColor(srcPos)

	// Apply the phosphor mask
	color = applyMask(color, srcPos)

	// Apply scanlines
	color = applyScanlines(color, srcPos)

	// Apply glow
	color = applyGlow(color, srcPos)

	return color
}

/*
// https://glsl.app#H4sIAH165WgCA9VYW28TRxR-JlL-w0g81A6-JQQKQnlIQ4sqgZBI4KEVQuPdWXvEemY7OxvbVP3v_c6Z2ZttlEjkhUiI3TNnzuU71_XjW-VKbY14OpsJVR4fHR8VTiWaaUu9WBYiy630r_bppVwVuXJnr3F2fKSNuFXJmahu8WorT2_nAg9fEptbxzyV0Zl1q8j4xanS5pWHRJzWZ6wNh16vVIfM0qovK1uVXXJjA91QG19B5t-nzz-zuseFk4uVFE4tyOrrm8sPN0xPVaaNEtdXl29_F-eTGRHZptaiwVD8e3wk8OcUpJqeuWIa7kLLf_Huufin0sbr5CZYMWgti0-j4HYRBU-nUXA0u74wAgfkCqGZvdTflLioma7x1jLOiJFYa9vB2PWAxRSTjRhfiJVNB3gcidPJDOaDbbKpGbYtw7bLsA0MLD2x1qWkoBAnrOqkgYB4Wl9U_ofyybK1kv0YhPvDaPT3UHsny693IPdTo_YjaFmdClkU-ZZB0qapMa4vxubRdDoVb5QvhQxUkTm7En6pRLG0Jf45scJtIU0q5g5V7JUp-bxcytSuVSp6NVMKnYlUldqpNIp_V-VeF7kGbnQPThHBLKJCRNPyAcwrKo9LfE98UIVCXaNohSxhhNnW0SlFpj3u8a1Ul0Uut2KtDcxpcKxeBzpF8lC4YtMgZK4TmRPPbPL01XQaOwaiOe1V8GSze-83hsOoksI1m7zA-SPWTYB9_ARidYsgDnqmTMXZs-eT2ZAOQga0NgxfocZP2H4-G4lnzNGTgCzirGncQfqQS33U0HGMNeMCAXJjm4392hLQyt3KHGGwsBFJxAByeCOyv5TCpmnDGUQGdwBISN76NWTwWAyiH41fpy_pgW1qb2_7t2P-H7h9dtbcDgKQnbup2TU5gH7OtCtmuzjUIrrN_vMoWtXREoKpQk7Nc5l8FYV0qAubdVQCxFXh7C2SFVNQ5nmsCUoCyGlsmLjFXDy5CHbzy8luzrSqL6lEO6UBavD3BJDVEveLGiljcgylcq-y0ROa0bpT5exdm7fRuaRyThnUGlUyPay1X5I1hUo8eV3Wuu4q6Y7s79X1W8iRDp167a2FmrUEnOSRRi9RUKycQNvR36zxQHgrgATARjzprVODnyKRgOAKnHUrlKh_Io9NqT0l32xy1j3-yyKXLpCETykQgUhevq2IPKBUrW57fbwtuA3laZ9C8e3aMxRPGiFbOiR9B4Vt94QRP1fFeEdmJ11veBpQF65hZLil8E5Ls0A_I1hHolzRIdJa-xH3cPiIw3nIN6rzgE_cjiC8A0K4XHpVDAAuRsvkGYTMy0HNMybSkHvZ-AwGw88e7Dh6Qj7fneuhRi7qEOxn-5vcru-Z6KSDMlNiRFnnxw6AUE1TxFWWxZSe5wr5FvJVFBpztZOyJQrCViallJZOySj5emmrPBV-W4RkFPM2c2WGntkWCoO9N0YZhyYHyadLTBsUXJg-AaP3BpLTYIjaFAQlKmSeV642HyMWA3Ctqf_AWKVM2A_FNdUSO0CzBtWNhKCVoc4OwqoZkXwS5-N-YnKxRLGXSVKtqlx6yjdaOzCB617chYolokewgnOxgH-HW3K3Hc_QjhE-1gddr7VcWIMpRe-tBDTTu0Qg13h0jhvHqH47b2FQPojUFrwfk9qR84C29qUesBU4X0mHmP0IztwTHspkFvZgqPaDBdkPiGYrjdettEpCyWFfqlAYc1odsImiPVsxG5_21aLFzSan8S_u9lRgWLrapkg3u4NTdPYI2N1IqxeLto_0PpQWyjMb2uZuk-SlCv3RY8VpN_Gq5BGuPDrZ2C-lGc81NTNM60znIOK4Xrdw455VHTv_-ywroZT8-vgJ_QP6gsdonfRtAfBEAp2GGjGtHDp2nFQl1mABWCiT0LYHzZP7dBRaLjGedtracDihXYqlzO8jBXP8oJR569qVzJNgqxQLJ7dhxsYJ9VWpgmDNqxXGFw9bp8CMno42D9cQBENzMAwFup_R8MW-8vLFS4SX_eV9Ana8-JWmLJEWkXR6el6T5gx3iD3EQAo9D1jkKEhu_kPDD1-1j-Kn5Upv8BGZBwaqmfP-h-RK6vgTR5MA3NibLAvR3h3zu-Ov_R4NH6G7q0F309xZcyOgvawKl6gian5eFHZZRfuzEkyuf15i5_4HRd6b6M8SAAA

#version 300 es

precision highp float;
precision highp sampler2D;

in vec2 uv;
out vec4 out_color;

uniform vec2 u_resolution;
uniform float u_time;
uniform vec4 u_mouse;
uniform sampler2D u_textures[16];

#pragma region START

#define SCALE 4.0

vec2 resolution() {
    return u_resolution / SCALE;
}

vec4 quinticTexture(sampler2D sampler, vec2 p) {
  //return texture(sampler, p);
  ivec2 size = textureSize(sampler, 0);

  vec2 res = resolution();
  p.x -= mod(p.x, 1.0 / res.x);
  p.y -= mod(p.y, 1.0 / res.y);
  vec2 coords = p * res * SCALE;

  return texelFetch(sampler, ivec2(coords), 0);
}

vec4 quinticTextureMask(sampler2D sampler, vec2 p) {
return texture(sampler, p);
  ivec2 size = textureSize(sampler, 0);

  vec2 res = resolution();
  p.x -= mod(p.x, 1.0 / res.x);
  p.y -= mod(p.y, 1.0 / res.y);
  vec2 coords = p * res;

  return texelFetch(sampler, ivec2(coords), 0);
}

void applyMask(inout vec4 color) {
	/// Gets a color from the phosphor mask and brightens the shadowed pragma regions if desired
	/// Multiplies the resulting color into the output

	// Repeat for as many textures fit in the display window
  vec2 uDisplaySize = resolution();
  float uMaskScale = 0.3;//u_mouse.x / u_resolution.x;
  float uMaskBrightness = 0.8;
	vec2 maskUV = uv * (uDisplaySize / 256.0) * (1.0 / uMaskScale); //* vec2(1.0 , 5.0 / (uDisplaySize.y / resolution().y));

	// Repeat on non-power-of-two intervals to match the mask texture's odd interval
	// maskUV.x = mod(maskUV.x, 1.0 - ((1.0 / 256.0) * 196.0));
	// maskUV.y = mod(maskUV.y, 1.0 - ((1.0 / 256.0) * 226.0));

	// Get color from the mask texture
	vec4 maskColor = quinticTextureMask(u_textures[1], maskUV);

	// Brighten the black parts of the mask to improve overall brightness
	maskColor.rgb += color.rgb * uMaskBrightness;

	// Apply the result
	color *= maskColor;
}

void applyScanlines(inout vec4 color, in vec2 uv) {
	/// Gets the brightness of the current fragment with respect to scanlines
	/// Multiplies the resulting brightness into the output

	// Linear sawtooth wave applied either horizontally or vertically
  float uVerticalScan = 0.0;
  float uScanIntensity = 0.2;
  float uZoom = 1.3;
	float scanLum = (mod(uv.x, 1.0 / resolution().x) * resolution().x * uVerticalScan) + (mod(uv.y * uZoom, 1.0 / resolution().y) * resolution().y * (1.0 - uVerticalScan));

	// Turn the sawtooth into a triangle wave, smoothen it, and scale by the intensity uniform
	scanLum = (smoothstep(0.0, 0.5, abs(scanLum - 0.5)) * (-2.0 * uScanIntensity)) + 1.0;

	// Apply the result
	color.rgb *= scanLum;
}

void applyGlow(inout vec4 color, in vec2 uv) {
	/// Applies a short-range bloom effect to bleed bright pixels into the surrounding area
	/// Should typically be applied after scanlines and the phosphor mask

  float uGlowAmount = 0.3;
	// Only do the expensive blur effect if it will be seen
  // Save the size of a texel into a vec2
  vec2 texelSize = 1.0 / resolution();

  // Accumulate samples from the surrounding texels
  vec4 glowColor = quinticTexture(u_textures[0], uv);
  // Diagonals
  glowColor += quinticTexture(u_textures[0], uv + vec2(-texelSize.x, -texelSize.y));
  glowColor += quinticTexture(u_textures[0], uv + vec2(-texelSize.x,  texelSize.y));
  glowColor += quinticTexture(u_textures[0], uv + vec2( texelSize.x, -texelSize.y));
  glowColor += quinticTexture(u_textures[0], uv + vec2( texelSize.x,  texelSize.y));
  // Cardinals
  glowColor += quinticTexture(u_textures[0], uv + vec2(0.0, -texelSize.y));
  glowColor += quinticTexture(u_textures[0], uv + vec2(0.0,  texelSize.y));
  glowColor += quinticTexture(u_textures[0], uv + vec2( -texelSize.x, 0.0));
  glowColor += quinticTexture(u_textures[0], uv + vec2( texelSize.x,  0.0));
  // Reduce the values back down to 0-1
  glowColor *= 0.11111111;

  // Add the result to the output
  color.rgb += glowColor.rgb * uGlowAmount;
}

vec4 getColor(in vec2 uv) {
	// Get a starting color using better-than-bilinear filtering
	vec4 col = quinticTexture(u_textures[0], uv);

	// Offset the UVs for the red and blue channels to simulate deconvergence
	col.r = quinticTexture(u_textures[0], uv - (0.5 / resolution())).r;
	col.b = quinticTexture(u_textures[0], uv + (0.5 / resolution())).b;

	// Calculate a grayscale color, keeping luminosity relatively constant
	float grayf = (0.2989 * col.r) + (0.5870 * col.g) + (0.1140 * col.b);
	vec4 gray = vec4(grayf, grayf, grayf, 1.0);

	return mix(col, gray, 0.4);
}

void main() {
	vec4 color = getColor(uv);

	// Apply the phosphor mask
	applyMask(color);

	// Apply scanlines
	applyScanlines(color, uv);

	// Apply glow
	applyGlow(color, uv);

  out_color = color;
}
*/
