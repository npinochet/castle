// https://glsl.app#H4sIAGByN2gCA61Ya2_bNhT9nAL9DxfYh9lp7Dhp2rXoMiBNtm5AuwFN2gEbioCWaJuIJGqUlMRd99937iUl0Y-gAZoARSVe8j4Oz33I311rVxlb0NPJhHT1-NHjR6XTiZG1hZkvSpplVtWvNtcrlZeZdodnkD1-ZAq61skhNdd4tU3Nb0eEh8vEZtbJnqYwM-vysPHS6cpmTQ2NkLYysQZhbXIdLYu25jK3TRUvdz7wCX1bN9D598HzT2Luu9Kpea7I6Tl7fX5x8v5C1lM9M4Wm89OTtz_T0Xiy6duZqcpMLc_N59ha8O2kKnXCiGzx4p2qrs796-ZBFr52AK8udFVtys_s6zfvN5c_alebRGXnidqCFK_-VtS6qEy93BT_qVy5ufomszcnALOIw-i8gDpozbaEzoZcphJ9YZKrO476DVuEOrEF6DbfIvtVZWqNCBGov1tT6U1Uox2vVXJl8vlWSO8S_WVtLjyRK-_JOBjSv48fEf6cBqGKFabSvqcNDv4Xzh7RP40pcEMXnoCDyLHwtOdpVVJQbeS1ArvomAJvmWuDbv9kKK6RPwj72Bi7CClROb6l0THlNh3gcY8OxhP4h23j23bDst-wjDcs_Yb9fd5yDAGNeLcsisnEWpey1ZJ2xf5uFzgf82I5K3AOOBhohZpWFAIIICJKnf2i62TRBykwDPz-YYjZo2pNSqossyWnzIBM0VUUqSYC487-_j690XVFyq_SzNmc6oWmcmEr_HOU4zipIqWppB2SROTVQqX2Rqe0UiEqMjNKdWWcToP6d01WmzIziJ_PAQdeKObBIK7digDulU3tofEBI5QdUULvdanBN1CPVAWPimV75RXNTA0loiL1JYduTAHfunuIS9E2DkSlRXIWeybjp-uivuqI_AV7J-oZoA8fsdhc44YHq-b26fDZ8_FkKBLPnd7Q8BVi3RUnByzbo2eyYxCrAEGEb53PoAj7vQoN0qqwxajElbiRnY3qG8vQanetMgBv4SV4IyjJhQb4vq_Ipmm3U1T6eJAXnvXtq6f-iAbwjotsHNrBS34Qr7rzzOvofEgdPu9h6A4fHnaHfUgg5DobY5897keydirbugIA8KMe9mkv3E2k29-i9nyZospeUakcEsDOIkPALi-dvQYrUW1VlgXy8-1DT2d57OZTenLsvZWX3S0tKpg-4WSMcgCrPspdANVq3Exfbk4Zem21mcNI_25kWMtnCa9nbIguaZzTBRKJc5Yfbky9YHe4G3PYVWvsa8kb6d7I4BDvW-hRDvX7prYWZm4U8OSQDKqGhmHtCAXGfLZFDYiXBCiAtvTpbBllX9y8JfcmcW6uNG8RH8ZiblFSnTmhd_wiR_m24eWBUBTwrdT-PtVumaCrK3zFsUdDehKpWbKYbW5Vh-K-po73-8IwWlMbkfZCqj8X3RZLwVxR7Ywq5qhYjO0eVTkLQW5T70nJRqAQTj3rOMk9SKGLQ3mMhD9d1bocMMZoJuNnUDMF8dptI14b-mI2OoTTCHYFf8iecDRfZ73PluNW9Sbveb66L-XZCHNUoS1ZV48cUOH05rvXs1kg9zTTYJ5nLpUGzTQib4XUwDCXMrmV0ypoPl_YJkupXpaeljTtOaxmqJp9ygjiG62zA-Jc4wp8GnbpZ5CZoRShgWuHnVNrM6xf-gW5mAHTk35iXIf05Ut4_5EvqXtfrsmXrTzQqMuHfmzt2hx790eB2FIPhb4t-TaRrdOscS2A8B2d9sZwMQRcWhc4icVB7Rrtr2JH4uQ0F0S5_6HwgKY8uLSc5cuTvXKLIgqNeTNh2Lkdxk80nyRJkzeYcjkReP5B828bRHx9opMrmNg4ojlCbhvF-pwZ9YsJ-gVI5W3C3JlRc1ugfcpCrwT1_qtakAXS1WnUBcgVJnoLTfyBFPc4frPiSNXDeryqeJvHAP1UOdzhN4Iu1esBPRd9Dwnx6uVxnj4otJFCmRDTJvEpiRGvQdZMeezBhIzSY2kyOlgzjao8GR-Ev1DJfQJiVOwrOR9eafs7UWWH-53CdjBa-WLe2UG977__5rqWvVzx7xhpFPyuMMOsToZzlaMio_L6qlwFeWIx6SRcRZhJ_VyJDlFj3uu_P5pKxhldo5aP6oUqRlPD5RyTy8xkWIS4nThx4t4lJJTV2ayCVXb0w0eUKxj0AMJf_qTCdVACowX3Ip6_TChwafelXyQ88cL0-F71iyds7tJrlXQ4HPNsKXqm99LDU81WPdM-vFOVJd5fRXOnln7eCI36SuuSsc2aHF1cBg-n-TeKa41eg_BwEwXzxncmPj_jfocB7uWLlyCMxCzjFfx48QNPG7w0D0sHB0ft0lQg90SCGmjh54HXubf2H7fJ-PvJf1tzW-bC472HLHx05-YWn9eZP825erT6iZ0rE37u6DgijaYjtOcD9b_jQdj-nrftW7cfmNbniOhr3n_Crx-Kp_f1b4dwKSvs9Kc4T9sDfuha33uX853rAsf_6MncawgVAAA

#version 300 es

precision highp float;
precision highp sampler2D;

in vec2 uv;
out vec4 out_color;

uniform vec2 u_resolution;
uniform float u_time;
uniform vec4 u_mouse;
uniform sampler2D u_textures[16];

#pragma region START

#define SCALE 4.0

uniform vec2 uDisplaySize;
uniform float uAspect;
uniform sampler2D uMaskSampler;
uniform float uMaskBrightness;
uniform float uDoBGR;
uniform float uVerticalScan;
uniform float uScanIntensity;
uniform float uWarp;
uniform float uGlowAmount;
uniform float uDoIntScale;
uniform float uInterlaceTick;
uniform float uDoInterlace;
uniform float uDeconverge;
uniform float uHalation;
uniform sampler2D uNoiseSampler;
uniform sampler2D uBackimg;
uniform float uDoBackimg;
uniform float uZoom;

vec2 resolution() {
    return u_resolution / SCALE;
}

vec4 quinticTexture( sampler2D sampler, vec2 p ) {
  ivec2 size = textureSize(sampler, 0);

  vec2 res = resolution();
  p.x -= mod(p.x, 1.0 / res.x);
  p.y -= mod(p.y, 1.0 / res.y);
  //p.y = 1. - p.y;
  vec2 coords = p * res * SCALE;
  //coords.y = float(size.y) - coords.y;

  return texelFetch(sampler, ivec2(coords), 0);
}

void applyMask( inout vec4 color) {
	/// Gets a color from the phosphor mask and brightens the shadowed pragma regions if desired
	/// Multiplies the resulting color into the output
  //return;
	
	// Repeat for as many textures fit in the display window
  vec2 uDisplaySize = resolution();
  float uMaskScale = 0.3;
  float uMaskBrightness = 0.8;
	vec2 maskUV = uv * ( uDisplaySize / 256.0) * ( 1.0 / uMaskScale); //* vec2(1.0 , 5.0 / (uDisplaySize.y / resolution().y));
	
	// Repeat on non-power-of-two intervals to match the mask texture's odd interval
	//maskUV.x = mod(maskUV.x, 1.0 - ((uDoBGR / 256.0) * 196.0));
	//maskUV.y = mod(maskUV.y, 1.0 - ((1.0 / 256.0) * 226.0));
	
	// Get color from the mask texture
	vec4 maskColor = texture( u_textures[2], maskUV);
	
	// Brighten the black parts of the mask to improve overall brightness
	maskColor.rgb += color.rgb * uMaskBrightness;
	
	// Apply the result
	color *= maskColor;
}

void applyScanlines( inout vec4 color, in vec2 uv) {
	/// Gets the brightness of the current fragment with respect to scanlines
	/// Multiplies the resulting brightness into the output
	
	// Linear sawtooth wave applied either horizontally or vertically
  float uVerticalScan = 0.0;
  float uScanIntensity = 0.2;
  float uZoom = 1.3;
	float scanLum = ( mod( uv.x, 1.0 / resolution().x) * resolution().x * uVerticalScan) + ( mod( uv.y * uZoom, 1.0 / resolution().y) * resolution().y * ( 1.0 - uVerticalScan));
	
	// Turn the sawtooth into a triangle wave, smoothen it, and scale by the intensity uniform
	scanLum = ( smoothstep( 0.0, 0.5, abs( scanLum - 0.5)) * ( -2.0 * uScanIntensity)) + 1.0;
	
	// Apply the result
	color.rgb *= scanLum;
}

void applyGlow( inout vec4 color, in vec2 uv) {
	/// Applies a short-range bloom effect to bleed bright pixels into the surrounding area
	/// Should typically be applied after scanlines and the phosphor mask
	
	// See if the fragment is on the border
	bool is_border = ( (uv.x > 1.0) || (uv.x < 0.0) || (uv.y > 1.0) || (uv.y < 0.0) );
	
  float uGlowAmount = 0.3;
	// Only do the expensive blur effect if it will be seen
	if (true) {
			// Save the size of a texel into a vec2
			vec2 texelSize = 1.0 / resolution();
			
			// Accumulate samples from the surrounding texels
			vec4 glowColor = quinticTexture( u_textures[0], uv);
			// Diagonals
			glowColor += quinticTexture( u_textures[0], uv + vec2( -texelSize.x, -texelSize.y));
			glowColor += quinticTexture( u_textures[0], uv + vec2( -texelSize.x,  texelSize.y));
			glowColor += quinticTexture( u_textures[0], uv + vec2(  texelSize.x, -texelSize.y));
			glowColor += quinticTexture( u_textures[0], uv + vec2(  texelSize.x,  texelSize.y));
			// Cardinals
			glowColor += quinticTexture( u_textures[0], uv + vec2( 0.0, -texelSize.y));
			glowColor += quinticTexture( u_textures[0], uv + vec2( 0.0,  texelSize.y));
			glowColor += quinticTexture( u_textures[0], uv + vec2(  -texelSize.x, 0.0));
			glowColor += quinticTexture( u_textures[0], uv + vec2(  texelSize.x,  0.0));
			// Reduce the values back down to 0-1
			glowColor *= 0.11111111;
	
			// Add the result to the output
			color.rgb += glowColor.rgb * uGlowAmount;
		}
}

vec4 getColor( in vec2 uv) {
	/// Gets a base color from the game and applies color corrections
	
	// Get a starting color using better-than-bilinear filtering
	vec4 col = quinticTexture( u_textures[0], uv);
	
	// Offset the UVs for the red and blue channels to simulate deconvergence
	col.r = quinticTexture( u_textures[0], uv - ( 0.5 / resolution())).r;
	col.b = quinticTexture( u_textures[0], uv + ( 0.5 / resolution())).b;
	
	// Calculate a grayscale color, keeping luminosity relatively constant
	float grayf = (0.2989 * col.r) + (0.5870 * col.g) + (0.1140 * col.b);
	vec4 gray = vec4( grayf, grayf, grayf, 1.0);
	
	// Return the final color
	return mix(col, gray, 0.4);
}

void main() {
	vec4 color = getColor(uv);
  out_color = color;
  //return;
	
	// Apply the phosphor mask
	applyMask( color);
	
	// Apply scanlines
	applyScanlines( color, uv);
	
	// Apply glow
	applyGlow( color, uv);
	
  out_color = color;
  return;
}

